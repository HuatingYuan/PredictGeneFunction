


# Function: calculate the remaining uncertainty,  misinformation and recall of classification performance
#' 
#' @param score: The predicted score vector calculated from the classification model
#' @param label: The actual label value, the class label must be 1 or 0, and be of numeric type
#' @param weights: The weight of each object in 'score'
#' @param threshold: When the predicted score is greater than or equal to this value, it is considered positive
#' 
#' 

PerformanceRM <- function(score, label, weights, threshold=0.5) 
{
	predict.label <- as.numeric(score >=  threshold);

	TP <- sum(weights[names(label[(label == predict.label) & (label == 1)])]); 
	FP <- sum(weights[names(label[(label != predict.label) & (label == 0)])]); 
	# TN <- sum(weights[names(label[(label == predict.label) & (label == 0)])]); 
	FN <- sum(weights[names(label[(label != predict.label) & (label == 1)])]); 
	
	ru <- FN/(TP+FP+FN)   ## remaining uncertainty
	mi <- FP/(TP+FP+FN)   ## misinformation
	
	return(c(ru=ru, mi=mi))
}



#' TODO: Calculate the average performance measures for different prediction scores under each threshold 
#'       based on the threshold vector generated by the step size
#'       
#' @param scoreList: A list storing predicted scores
#' @param labelList: A list storing the actual label value
#' @param weights: A vector storing the weight of each object for each element of 'scoreList'
#' @param from: The starting value of threshold
#' @param to : The end value of the threshold
#' @param step: step size
#' 
#' 
MeanPerformanceRM <- function(scoreList, labelList, weights, from=1, to=0, step=0.01)
{
	if(length(scoreList) != length(labelList)){
		stop("scoreList与labelList without the same length")
	}
	
#	if(length(scoreList) == 1){
#		stop("length is 1，not using PerformanceMetricsList")
#	}
	
	thresholds = seq(from, to, by=step) 
	
	num.element = length(scoreList);
	
	results = sapply(thresholds, function(x){
				temp = sapply(1:num.element, function(i){
				  PerformanceRM(score=scoreList[[i]], label=labelList[[i]], threshold=x, weights=weights)
						})
				temp = rowMeans(temp, na.rm=TRUE);
				return(temp)
			})
	
	results <- t(results)
	Smeasure<- round(sqrt(results[,"ru"]^2 + results[,"mi"]^2), 3)
	thresholds <- thresholds
	
	results <- cbind(results, Smeasure, thresholds)
	return(results)
}




 



